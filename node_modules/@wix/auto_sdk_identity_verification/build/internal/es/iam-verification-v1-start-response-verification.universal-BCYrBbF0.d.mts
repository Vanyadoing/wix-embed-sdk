interface StartResponse {
    /** the identifier of the verification process */
    verificationId?: string;
}
interface StartRequest {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     * @format GUID
     */
    identityId?: string | null;
    /** the delivery target */
    target?: TargetWithLiterals;
}
declare enum Target {
    UNKNOWN_TARGET = "UNKNOWN_TARGET",
    EMAIL = "EMAIL"
}
/** @enumType */
type TargetWithLiterals = Target | 'UNKNOWN_TARGET' | 'EMAIL';
interface VerifyRequest {
    /**
     * the code to verify
     * @minLength 6
     * @maxLength 6
     */
    code?: string;
    /** the identifier of the verification process */
    verificationId?: string;
}
interface VerifyResponse {
}
interface VerifyDuringAuthenticationRequest {
    /** The code to verify. */
    code: string;
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StateMachineResponse extends StateMachineResponseStateDataOneOf {
    /** Current state of the login or registration process. */
    state?: StateTypeWithLiterals;
    /** Session token. If `state` is not `SUCCESS`, this field is undefined. */
    sessionToken?: string | null;
    /** Token that represents the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identity of the current member. */
    identity?: Identity;
    /** Additional data relevant to the login or registration process. */
    additionalData?: Record<string, CustomValue>;
}
/** @oneof */
interface StateMachineResponseStateDataOneOf {
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Login completed successfully. */
    SUCCESS = "SUCCESS",
    /** Indicates that the member needs the owner to approve their registration. */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /** Indicates that the member needs to verify their email. */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** Indicates that the `status` is not one that prevents the member logging in, meaning it's not `OFFLINE`, `BLOCKED`, or `DELETED`. */
    STATUS_CHECK = "STATUS_CHECK"
}
/** @enumType */
type StateTypeWithLiterals = StateType | 'UNKNOWN_STATE' | 'SUCCESS' | 'REQUIRE_OWNER_APPROVAL' | 'REQUIRE_EMAIL_VERIFICATION' | 'STATUS_CHECK';
interface Identity {
    /**
     * Identity ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the identity is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the identity.
     *
     * Ignored when creating an identity.
     */
    revision?: string | null;
    /**
     * Date and time the identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the identity was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** Custom attributes. */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity verification factors.
     * @maxSize 10
     * @readonly
     */
    factors?: Factor[];
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /**
     * IDP connection ID.
     * @format GUID
     */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /**
     * Authenticator connection ID.
     * @format GUID
     */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /**
     * List of profile labels.
     * @maxSize 2000
     */
    labels?: string[];
    /**
     * Profile language.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatusWithLiterals;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /**
     * Company name.
     * @maxLength 1000
     */
    company?: string | null;
    /**
     * Position within company.
     * @maxLength 1000
     */
    position?: string | null;
    /**
     * Profile birthdate in `YYYY-MM-DD` format.
     * @format LOCAL_DATE
     */
    birthdate?: string | null;
    /**
     * Profile slug.
     * @maxLength 255
     */
    slug?: string | null;
    /** Consent to be added to mailing list */
    subscription?: boolean | null;
    /**
     * Government id for personal/corporate (Vat ID).
     * @maxLength 1000
     */
    vatId?: string | null;
}
declare enum PrivacyStatus {
    /** No defined privacy status. */
    UNDEFINED = "UNDEFINED",
    /** Profile details, such as profile name and profile picture, are visible to other members. */
    PUBLIC = "PUBLIC",
    /** Profile details aren't visible to other members. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
type PrivacyStatusWithLiterals = PrivacyStatus | 'UNDEFINED' | 'PUBLIC' | 'PRIVATE';
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /**
     * Email address.
     * @format EMAIL
     */
    email?: string;
    /** Email tag. */
    tag?: EmailTagWithLiterals;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
/** @enumType */
type EmailTagWithLiterals = EmailTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'WORK';
interface Phone {
    /**
     * Phone country code.
     * @format COUNTRY
     */
    countryCode?: string | null;
    /**
     * Phone number.
     * @format PHONE
     */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTagWithLiterals;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
/** @enumType */
type PhoneTagWithLiterals = PhoneTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'MOBILE' | 'WORK' | 'FAX';
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTagWithLiterals;
}
/** Physical address */
interface Address {
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains apartment, suite, and floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
/** @enumType */
type AddressTagWithLiterals = AddressTag | 'UNTAGGED' | 'HOME' | 'WORK' | 'BILLING' | 'SHIPPING';
interface Metadata {
    /**
     * General tags. For example, `"isOwner"`.
     * @readonly
     */
    tags?: string[];
}
interface Email {
    /**
     * Email address.
     * @format EMAIL
     */
    address?: string;
    /** Whether the email address is verified. */
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusNameWithLiterals;
    reasons?: ReasonWithLiterals[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
/** @enumType */
type StatusNameWithLiterals = StatusName | 'UNKNOWN_STATUS' | 'PENDING' | 'ACTIVE' | 'DELETED' | 'BLOCKED' | 'OFFLINE';
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'PENDING_ADMIN_APPROVAL_REQUIRED' | 'PENDING_EMAIL_VERIFICATION_REQUIRED';
interface Factor {
    /**
     * Factor ID.
     * @format GUID
     */
    factorId?: string;
    /** Factor type. */
    type?: FactorTypeWithLiterals;
    /** Factor status. */
    status?: StatusWithLiterals;
}
declare enum FactorType {
    /** Unknown factor type. */
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    /** Requires a password. */
    PASSWORD = "PASSWORD",
    /** Requires a code sent via SMS. */
    SMS = "SMS",
    /** Requires a code sent by phone call. */
    CALL = "CALL",
    /** Requires a code sent by email. */
    EMAIL = "EMAIL",
    /** Requires authentication via an authenticator app. */
    TOTP = "TOTP",
    /** Requires authentication via a push notification. */
    PUSH = "PUSH",
    /** Requires authentication via WebAuthn/passkey. */
    WEBAUTHN = "WEBAUTHN"
}
/** @enumType */
type FactorTypeWithLiterals = FactorType | 'UNKNOWN_FACTOR_TYPE' | 'PASSWORD' | 'SMS' | 'CALL' | 'EMAIL' | 'TOTP' | 'PUSH' | 'WEBAUTHN';
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
/** @enumType */
type StatusWithLiterals = Status | 'INACTIVE' | 'ACTIVE' | 'REQUIRE_REENROLL';
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface RequireMfaData {
    /**
     * The factors available for the user to perform the required MFA.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
interface V1Factor {
    /** Type of verification factor. */
    factorType?: FactorTypeWithLiterals;
    /** Availability status for second factor */
    factorStatus?: FactorStatusWithLiterals;
}
declare enum FactorStatus {
    UNKNOWN_FACTOR_STATUS = "UNKNOWN_FACTOR_STATUS",
    ENABLED = "ENABLED",
    REQUIRE_ACTIVATION = "REQUIRE_ACTIVATION",
    REQUIRE_REENROLL = "REQUIRE_REENROLL",
    ENABLED_BY_RULE = "ENABLED_BY_RULE",
    DISABLED_BY_RULE = "DISABLED_BY_RULE"
}
/** @enumType */
type FactorStatusWithLiterals = FactorStatus | 'UNKNOWN_FACTOR_STATUS' | 'ENABLED' | 'REQUIRE_ACTIVATION' | 'REQUIRE_REENROLL' | 'ENABLED_BY_RULE' | 'DISABLED_BY_RULE';
declare enum MfaReason {
    UNKNOWN_MFA_REASON = "UNKNOWN_MFA_REASON",
    /** Mfa is required due to user settings */
    USER_SETTINGS = "USER_SETTINGS",
    /** Mfa is required due to high risk login */
    HIGH_RISK_LOGIN = "HIGH_RISK_LOGIN"
}
/** @enumType */
type MfaReasonWithLiterals = MfaReason | 'UNKNOWN_MFA_REASON' | 'USER_SETTINGS' | 'HIGH_RISK_LOGIN';
interface MfaChallengeData {
    /** Type of verifation factor. */
    factorType?: FactorTypeWithLiterals;
    verificationChallengeData?: VerificationChallenge;
    /**
     * Factors types the member can choose from to verify themselves.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
interface VerificationChallenge extends VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
    /** @maxLength 200 */
    hint?: string | null;
}
/** @oneof */
interface VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
}
interface PushChallengeData {
    /**
     * This should be tied to a specific push notification.
     * It will be sent in subsequent requests to verify the factor.
     * @maxLength 36
     */
    transactionId?: string;
}
interface WebAuthnChallengeData {
    /**
     * A unique identifier for this challenge that will be used to correlate
     * the authentication response with this challenge.
     * This should be a cryptographically random GUID to prevent guessing attacks.
     * @format GUID
     */
    challengeId?: string;
    /**
     * The challenge that will be signed by the authenticator during the WebAuthn authentication ceremony.
     * This should be a cryptographically secure random value with at least 16 bytes of entropy.
     * The value is used to prevent replay attacks and MUST be randomly generated by the implementer.
     */
    challenge?: Uint8Array;
    /**
     * The timeout in milliseconds for the WebAuthn authentication ceremony.
     * After this time, the challenge will be considered expired and the authentication will need to be restarted.
     * This is optional and may be overridden by the client if provided.
     * The WebAuthn spec recommends a timeout of at least 1 minute (60000ms).
     */
    timeoutMs?: number | null;
    /**
     * Optional list of credentials that are acceptable for this authentication ceremony.
     * If empty, all credentials associated with the user will be considered.
     * @maxSize 10
     */
    allowCredentials?: PublicKeyCredentialDescriptor[];
    /** Specifies the requirement for user verification during the authentication ceremony. */
    userVerification?: UserVerificationRequirementWithLiterals;
    /**
     * Optional hints to guide the client UI
     * Examples include "security-key" to emphasize external authenticators
     * or "client-device" to emphasize built-in authenticators
     * @maxLength 50
     * @maxSize 10
     */
    hints?: string[];
    /**
     * Optional extensions for the authentication ceremony
     * Provides additional parameters for specialized WebAuthn functionality
     */
    extensions?: AuthenticationExtensionInputs;
}
interface PublicKeyCredentialDescriptor {
    /** The credential ID */
    _id?: Uint8Array;
    /**
     * An optional hint as to the transports used by the credential
     * Examples include "usb", "nfc", "ble", "internal", "hybrid"
     * @maxLength 50
     * @maxSize 10
     */
    transports?: string[];
}
declare enum UserVerificationRequirement {
    /** Default unspecified value */
    USER_VERIFICATION_UNSPECIFIED = "USER_VERIFICATION_UNSPECIFIED",
    /**
     * The Relying Party requires user verification and will fail the operation if the response doesn't have the UV flag
     * set
     */
    USER_VERIFICATION_REQUIRED = "USER_VERIFICATION_REQUIRED",
    /** The Relying Party prefers user verification but will not fail the operation if unavailable */
    USER_VERIFICATION_PREFERRED = "USER_VERIFICATION_PREFERRED",
    /** The Relying Party does not want user verification employed (e.g., to minimize disruption to the user experience) */
    USER_VERIFICATION_DISCOURAGED = "USER_VERIFICATION_DISCOURAGED"
}
/** @enumType */
type UserVerificationRequirementWithLiterals = UserVerificationRequirement | 'USER_VERIFICATION_UNSPECIFIED' | 'USER_VERIFICATION_REQUIRED' | 'USER_VERIFICATION_PREFERRED' | 'USER_VERIFICATION_DISCOURAGED';
interface AuthenticationExtensionInputs extends AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
    /**
     * FIDO AppID Extension (appid)
     * An AppID that was used for previously registered U2F authenticators
     * This makes already-registered U2F credentials forward-compatible with the WebAuthn API
     * @maxLength 256
     */
    appid?: string;
    /**
     * User Verification Method Extension (uvm)
     * Requests the authenticator to report which verification methods were used
     * Examples include fingerprint, PIN, or facial recognition
     */
    uvm?: boolean;
}
/** @oneof */
interface AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
}
interface ResendDuringAuthenticationRequest {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}
interface StartOptions {
    /**
     * an identity_Id.
     * If not provided - currently, an exception is thrown. In the future the identity from identity response will be taken.
     * @format GUID
     */
    identityId?: string | null;
    /** the delivery target */
    target?: TargetWithLiterals;
}
interface VerifyDuringAuthenticationOptions {
    /** A state token representing the `REQUIRE_EMAIL_VERIFICATION` state. */
    stateToken: string;
}

export { type AuthenticationExtensionInputs as $, AddressTag as A, type Email as B, type Connection as C, type StatusV2 as D, EmailTag as E, FactorType as F, type Factor as G, type CustomValue as H, type Identity as I, type CustomValueValueOneOf as J, type MapValue as K, type ListValue as L, MfaReason as M, type RequireMfaData as N, type V1Factor as O, PrivacyStatus as P, type MfaChallengeData as Q, Reason as R, type StartOptions as S, Target as T, UserVerificationRequirement as U, type VerifyDuringAuthenticationOptions as V, type VerificationChallenge as W, type VerificationChallengeFactorChallengeDataOneOf as X, type PushChallengeData as Y, type WebAuthnChallengeData as Z, type PublicKeyCredentialDescriptor as _, type StartResponse as a, type AuthenticationExtensionInputsLargeBlobOperationOneOf as a0, type ResendDuringAuthenticationRequest as a1, type StateMachineResponse as b, StateType as c, PhoneTag as d, StatusName as e, Status as f, FactorStatus as g, type StartRequest as h, type VerifyRequest as i, type VerifyResponse as j, type VerifyDuringAuthenticationRequest as k, type StateMachineResponseStateDataOneOf as l, type ConnectionTypeOneOf as m, type IdpConnection as n, type AuthenticatorConnection as o, type IdentityProfile as p, type CustomField as q, type V1CustomValue as r, type V1CustomValueValueOneOf as s, type V1ListValue as t, type V1MapValue as u, type SecondaryEmail as v, type Phone as w, type AddressWrapper as x, type Address as y, type Metadata as z };
