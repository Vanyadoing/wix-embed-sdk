interface RefreshToken {
    token?: string;
}
/**
 * AuthorizeRequest is sent by the client to the authorization server to initiate
 * the authorization process.
 */
interface AuthorizeRequest {
    /**
     * ID of the Wix OAuth app requesting authorization.
     * @format GUID
     */
    clientId?: string;
    /**
     * Desired authorization [grant type](https://auth0.com/docs/authenticate/protocols/oauth#grant-types).
     *
     * Supported values:
     * + `code`: The endpoint returns an authorization code that can be used to obtain an access token.
     * @minLength 1
     */
    responseType?: string;
    /**
     * URI to redirect the browser to after authentication and authorization. The browser is redirected to this URI whether the authentication and authorization process is successful or not.
     * @minLength 1
     */
    redirectUri?: string | null;
    /**
     * Desired scope of access. If this field is left empty, only an access token is granted.
     * To received a refresh token, pass `offline_access` as the value of this field.
     */
    scope?: string | null;
    /**
     * A value used to confirm the state of an application before and after it makes an authorization
     * request. If a value for this field is set in the request, it's added to the `redirectUri` when the browser
     * is redirected there.
     * Learn more about [using the state parameter](https://auth0.com/docs/secure/attack-protection/state-parameters).
     * @minLength 1
     */
    state?: string;
    /**
     * esired response format.
     *
     * Supported values:
     * + `query`: The response parameters are encoded as query string parameters and added to the `redirectUri` when redirecting.
     * + `fragment`: The response parameters are encoded as URI fragment parameters and added to the `redirectUri` when redirecting.
     * + `web_message`: The response parameters are encoded as a JSON object and added to the body of a [web message response](https://datatracker.ietf.org/doc/html/draft-sakimura-oauth-wmrm-00).
     *
     * Default value: `query`
     */
    responseMode?: string | null;
    /**
     * Code challenge to use for PKCE verification.
     * This field is only used if `responseType` is set to `code`.
     */
    codeChallenge?: string | null;
    /**
     * Code challenge method to use for PKCE verification.
     * This field is only used if `responseType` is set to `code`.
     *
     * Supported values:
     * + `S256`: The code challenge is transformed using SHA-256 encyption.
     * + `S512`: The code challenge is transformed using SHA-512 encyption.
     */
    codeChallengeMethod?: string | null;
    /** Session token of the site visitor to authorize. */
    sessionToken?: string | null;
    /**
     * URL to redirect user to sign in
     * @format SECURE_WEB_URL
     */
    signInUrl?: string | null;
}
interface RawHttpResponse {
    body?: Uint8Array;
    statusCode?: number | null;
    headers?: HeadersEntry[];
}
interface HeadersEntry {
    key?: string;
    value?: string;
}
interface RawHttpRequest {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface PathParametersEntry {
    key?: string;
    value?: string;
}
interface QueryParametersEntry {
    key?: string;
    value?: string;
}
interface DeviceCodeRequest {
    /** The ID of the application that asks for authorization. */
    clientId?: string;
    /**
     * scope is a space-delimited string that specifies the requested scope of the
     * access request.
     */
    scope?: string | null;
}
interface DeviceCodeResponse {
    /** is the unique code for the device. When the user goes to the verification_uri in their browser-based device, this code will be bound to their session. */
    deviceCode?: string;
    /** contains the code that should be input at the verification_uri to authorize the device. */
    userCode?: string;
    /** contains the URL the user should visit to authorize the device. */
    verificationUri?: string;
    /** indicates the lifetime (in seconds) of the device_code and user_code. */
    expiresIn?: number;
    /** indicates the interval (in seconds) at which the app should poll the token URL to request a token. clients MUST use 5 as the default */
    interval?: number | null;
}
interface DeviceVerifyRequest {
    /** User code representing a currently authorizing device. */
    userCode?: string;
}
interface DeviceVerifyResponse {
}
interface DeviceVerifyV2Request {
    /**
     * User code representing a currently authorizing device.
     * @minLength 8
     * @maxLength 8
     */
    userCode?: string;
}
interface DeviceVerifyV2Response {
}
interface InvalidateUserCodeRequest {
    /** user code to invalidate. Only the authorizing identity is able to invalidate it. */
    userCode?: string;
}
interface InvalidateUserCodeResponse {
}
interface RevokeRefreshTokenRequest {
    /** The refresh token itself. Anyone with the token itself is able to revoke it. */
    token?: string;
}
interface RevokeRefreshTokenResponse {
}
interface TokenInfoResponse {
    active?: boolean;
    /** subject type. */
    subjectType?: SubjectTypeWithLiterals;
    /** subject id */
    subjectId?: string;
    /** Expiration time of the token */
    exp?: string | null;
    /** Issued time of the token */
    iat?: string | null;
    /** Client id */
    clientId?: string;
    /** Account id */
    accountId?: string | null;
    /** Site id */
    siteId?: string | null;
    /** Instance Id */
    instanceId?: string | null;
    /**
     * Vendor Product Id
     * @maxLength 100
     */
    vendorProductId?: string | null;
}
declare enum SubjectType {
    /** unknown subject type */
    UNKNOWN = "UNKNOWN",
    /** user subject type */
    USER = "USER",
    /** visitor subject type */
    VISITOR = "VISITOR",
    /** member subject type */
    MEMBER = "MEMBER",
    /** app subject type */
    APP = "APP"
}
/** @enumType */
type SubjectTypeWithLiterals = SubjectType | 'UNKNOWN' | 'USER' | 'VISITOR' | 'MEMBER' | 'APP';
interface Empty {
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    _id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface TokenOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}
interface TokenInfoOptions {
    body?: Uint8Array;
    pathParams?: PathParametersEntry[];
    queryParams?: QueryParametersEntry[];
    headers?: HeadersEntry[];
    method?: string;
    rawPath?: string;
    rawQuery?: string;
}

export { type AuthorizeRequest as A, type DeviceCodeRequest as D, type Empty as E, type HeadersEntry as H, type InvalidateUserCodeRequest as I, type PathParametersEntry as P, type QueryParametersEntry as Q, type RawHttpResponse as R, SubjectType as S, type TokenOptions as T, type TokenInfoOptions as a, type TokenInfoResponse as b, type RefreshToken as c, type RawHttpRequest as d, type DeviceCodeResponse as e, type DeviceVerifyRequest as f, type DeviceVerifyResponse as g, type DeviceVerifyV2Request as h, type DeviceVerifyV2Response as i, type InvalidateUserCodeResponse as j, type RevokeRefreshTokenRequest as k, type RevokeRefreshTokenResponse as l, type DomainEvent as m, type DomainEventBodyOneOf as n, type EntityCreatedEvent as o, type RestoreInfo as p, type EntityUpdatedEvent as q, type EntityDeletedEvent as r, type ActionEvent as s };
