/** Recovery token proto is the saved data on the recovery token. */
interface RecoveryToken {
    /**
     * Recovery token ID
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Represents the time this SessionToken was created
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * tenantId
     * @format GUID
     * @readonly
     */
    tenantId?: string;
    /**
     * TenantType
     * @readonly
     */
    tenantType?: TenantTypeWithLiterals;
    /**
     * identity id
     * @format GUID
     * @readonly
     */
    identityId?: string;
}
declare enum TenantType {
    UNKNOWN_TENANT_TYPE = "UNKNOWN_TENANT_TYPE",
    ACCOUNT = "ACCOUNT",
    SITE = "SITE",
    ROOT = "ROOT"
}
/** @enumType */
type TenantTypeWithLiterals = TenantType | 'UNKNOWN_TENANT_TYPE' | 'ACCOUNT' | 'SITE' | 'ROOT';
interface SendRecoveryEmailRequest {
    /**
     * Email address associated with the account to recover.
     * @format EMAIL
     */
    email: string;
    /**
     * 2-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format of the email to be sent.
     *
     * If no language is specified, the language specified in the member's profile is used.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Where to redirect to after successfully resetting the password. */
    redirect?: Redirect;
}
interface Redirect {
    /**
     * URL to redirect to after successfully resetting the password.
     * @maxLength 1000
     */
    url?: string;
    /**
     * Client ID of the [OAuth app](https://dev.wix.com/docs/go-headless/getting-started/setup/authentication/create-an-oauth-app-for-visitors-and-members) your Headless project is using.
     * @format GUID
     */
    clientId?: string | null;
}
interface SendRecoveryEmailResponse {
}
interface SendActivationEmailRequest {
    /**
     * Id of the activating user
     * @format GUID
     */
    identityId: string;
    /** Options for the activation email */
    emailOptions?: EmailOptions;
}
interface EmailOptions {
    /**
     * language of the email - if not received will fallback to the identity language
     * @format LANGUAGE
     */
    language?: string | null;
    /** Where to redirect after a successful activation process */
    redirect?: Redirect;
}
interface SendActivationEmailResponse {
}
interface RecoverRequest {
    /** recovery token */
    recoveryToken: string;
    /** new password to set for the identity */
    password?: string | null;
}
interface StateMachineResponse extends StateMachineResponseStateDataOneOf {
    /** Current state of the login or registration process. */
    state?: StateTypeWithLiterals;
    /** Session token. If `state` is not `SUCCESS`, this field is undefined. */
    sessionToken?: string | null;
    /** Token that represents the current state of the login or registration process. */
    stateToken?: string | null;
    /** Identity of the current member. */
    identity?: Identity;
    /** Additional data relevant to the login or registration process. */
    additionalData?: Record<string, CustomValue>;
}
/** @oneof */
interface StateMachineResponseStateDataOneOf {
}
declare enum StateType {
    /** Initial unknown state. */
    UNKNOWN_STATE = "UNKNOWN_STATE",
    /** Login completed successfully. */
    SUCCESS = "SUCCESS",
    /** Indicates that the member needs the owner to approve their registration. */
    REQUIRE_OWNER_APPROVAL = "REQUIRE_OWNER_APPROVAL",
    /** Indicates that the member needs to verify their email. */
    REQUIRE_EMAIL_VERIFICATION = "REQUIRE_EMAIL_VERIFICATION",
    /** Indicates that the `status` is not one that prevents the member logging in, meaning it's not `OFFLINE`, `BLOCKED`, or `DELETED`. */
    STATUS_CHECK = "STATUS_CHECK"
}
/** @enumType */
type StateTypeWithLiterals = StateType | 'UNKNOWN_STATE' | 'SUCCESS' | 'REQUIRE_OWNER_APPROVAL' | 'REQUIRE_EMAIL_VERIFICATION' | 'STATUS_CHECK';
interface Identity {
    /**
     * Identity ID.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Revision number, which increments by 1 each time the identity is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the identity.
     *
     * Ignored when creating an identity.
     */
    revision?: string | null;
    /**
     * Date and time the identity was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the identity was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** The identity configured connections to authenticate with. */
    connections?: Connection[];
    /** Identity profile. */
    identityProfile?: IdentityProfile;
    /**
     * Additional information about the identity that can impact user access.
     * This data cannot be set.
     */
    metadata?: Metadata;
    /** Identity email address. */
    email?: Email;
    /** Identity's current status. */
    status?: StatusV2;
    /** Custom attributes. */
    customAttributes?: Record<string, any> | null;
    /**
     * Identity verification factors.
     * @maxSize 10
     * @readonly
     */
    factors?: Factor[];
}
interface Connection extends ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
/** @oneof */
interface ConnectionTypeOneOf {
    /** IDP connection. */
    idpConnection?: IdpConnection;
    /** Authenticator connection. */
    authenticatorConnection?: AuthenticatorConnection;
}
interface IdpConnection {
    /**
     * IDP connection ID.
     * @format GUID
     */
    idpConnectionId?: string;
    /** IDP user ID. */
    idpUserId?: string;
}
interface AuthenticatorConnection {
    /**
     * Authenticator connection ID.
     * @format GUID
     */
    authenticatorConnectionId?: string;
    /** Whether re-enrollment is required. */
    reEnrollmentRequired?: boolean;
}
interface IdentityProfile {
    /** Profile first name. */
    firstName?: string | null;
    /** Profile last name. */
    lastName?: string | null;
    /** Profile nickname. */
    nickname?: string | null;
    /** Profile picture URL. */
    picture?: string | null;
    /**
     * Deprecated. Use `secondaryEmails` instead.
     * @deprecated Deprecated. Use `secondaryEmails` instead.
     * @replacedBy secondary_emails
     * @targetRemovalDate 2023-11-01
     */
    emails?: string[];
    /**
     * Deprecated. Use `phonesV2` instead.
     * @deprecated Deprecated. Use `phonesV2` instead.
     * @replacedBy phones_v2
     * @targetRemovalDate 2023-11-01
     */
    phones?: string[];
    /**
     * List of profile labels.
     * @maxSize 2000
     */
    labels?: string[];
    /**
     * Profile language.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Profile privacy status. */
    privacyStatus?: PrivacyStatusWithLiterals;
    /**
     * Any number of custom fields. [Custom fields](https://support.wix.com/en/article/adding-custom-fields-to-contacts)
     * are used to store additional information about your site or app's contacts.
     */
    customFields?: CustomField[];
    /** List of profile email addresses. */
    secondaryEmails?: SecondaryEmail[];
    /** List of profile phone numbers. */
    phonesV2?: Phone[];
    /** List of profile physical addresses. */
    addresses?: AddressWrapper[];
    /**
     * Company name.
     * @maxLength 1000
     */
    company?: string | null;
    /**
     * Position within company.
     * @maxLength 1000
     */
    position?: string | null;
    /**
     * Profile birthdate in `YYYY-MM-DD` format.
     * @format LOCAL_DATE
     */
    birthdate?: string | null;
    /**
     * Profile slug.
     * @maxLength 255
     */
    slug?: string | null;
    /** Consent to be added to mailing list */
    subscription?: boolean | null;
    /**
     * Government id for personal/corporate (Vat ID).
     * @maxLength 1000
     */
    vatId?: string | null;
}
declare enum PrivacyStatus {
    /** No defined privacy status. */
    UNDEFINED = "UNDEFINED",
    /** Profile details, such as profile name and profile picture, are visible to other members. */
    PUBLIC = "PUBLIC",
    /** Profile details aren't visible to other members. */
    PRIVATE = "PRIVATE"
}
/** @enumType */
type PrivacyStatusWithLiterals = PrivacyStatus | 'UNDEFINED' | 'PUBLIC' | 'PRIVATE';
interface CustomField {
    /**
     * Custom field name. The name must match one of the key properties of the objects returned by
     * [`List Extended Fields`](https://dev.wix.com/docs/rest/api-reference/contacts/extended-fields/list-extended-fields)
     * with the `custom.` prefix removed.
     */
    name?: string;
    /** Custom field value. */
    value?: V1CustomValue;
}
interface V1CustomValue extends V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
/** @oneof */
interface V1CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** Array of values. */
    listValue?: V1ListValue;
    /** Map of values. */
    mapValue?: V1MapValue;
}
interface V1ListValue {
    /** Custom value. */
    value?: V1CustomValue[];
}
interface V1MapValue {
    /** Mapped custom value. */
    value?: Record<string, V1CustomValue>;
}
interface SecondaryEmail {
    /**
     * Email address.
     * @format EMAIL
     */
    email?: string;
    /** Email tag. */
    tag?: EmailTagWithLiterals;
}
declare enum EmailTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    WORK = "WORK"
}
/** @enumType */
type EmailTagWithLiterals = EmailTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'WORK';
interface Phone {
    /**
     * Phone country code.
     * @format COUNTRY
     */
    countryCode?: string | null;
    /**
     * Phone number.
     * @format PHONE
     */
    phone?: string;
    /** Phone tag. */
    tag?: PhoneTagWithLiterals;
}
declare enum PhoneTag {
    UNTAGGED = "UNTAGGED",
    MAIN = "MAIN",
    HOME = "HOME",
    MOBILE = "MOBILE",
    WORK = "WORK",
    FAX = "FAX"
}
/** @enumType */
type PhoneTagWithLiterals = PhoneTag | 'UNTAGGED' | 'MAIN' | 'HOME' | 'MOBILE' | 'WORK' | 'FAX';
interface AddressWrapper {
    /** Address. */
    address?: Address;
    /** Address tag. */
    tag?: AddressTagWithLiterals;
}
/** Physical address */
interface Address {
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually a state, region, prefecture, or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Main address line, usually street and number as free text. */
    addressLine1?: string | null;
    /** Free text providing more detailed address info. Usually contains apartment, suite, and floor. */
    addressLine2?: string | null;
}
declare enum AddressTag {
    UNTAGGED = "UNTAGGED",
    HOME = "HOME",
    WORK = "WORK",
    BILLING = "BILLING",
    SHIPPING = "SHIPPING"
}
/** @enumType */
type AddressTagWithLiterals = AddressTag | 'UNTAGGED' | 'HOME' | 'WORK' | 'BILLING' | 'SHIPPING';
interface Metadata {
    /**
     * General tags. For example, `"isOwner"`.
     * @readonly
     */
    tags?: string[];
}
interface Email {
    /**
     * Email address.
     * @format EMAIL
     */
    address?: string;
    /** Whether the email address is verified. */
    isVerified?: boolean;
}
interface StatusV2 {
    name?: StatusNameWithLiterals;
    reasons?: ReasonWithLiterals[];
}
declare enum StatusName {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    DELETED = "DELETED",
    BLOCKED = "BLOCKED",
    OFFLINE = "OFFLINE"
}
/** @enumType */
type StatusNameWithLiterals = StatusName | 'UNKNOWN_STATUS' | 'PENDING' | 'ACTIVE' | 'DELETED' | 'BLOCKED' | 'OFFLINE';
declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    PENDING_ADMIN_APPROVAL_REQUIRED = "PENDING_ADMIN_APPROVAL_REQUIRED",
    PENDING_EMAIL_VERIFICATION_REQUIRED = "PENDING_EMAIL_VERIFICATION_REQUIRED"
}
/** @enumType */
type ReasonWithLiterals = Reason | 'UNKNOWN_REASON' | 'PENDING_ADMIN_APPROVAL_REQUIRED' | 'PENDING_EMAIL_VERIFICATION_REQUIRED';
interface Factor {
    /**
     * Factor ID.
     * @format GUID
     */
    factorId?: string;
    /** Factor type. */
    type?: FactorTypeWithLiterals;
    /** Factor status. */
    status?: StatusWithLiterals;
}
declare enum FactorType {
    /** Unknown factor type. */
    UNKNOWN_FACTOR_TYPE = "UNKNOWN_FACTOR_TYPE",
    /** Requires a password. */
    PASSWORD = "PASSWORD",
    /** Requires a code sent via SMS. */
    SMS = "SMS",
    /** Requires a code sent by phone call. */
    CALL = "CALL",
    /** Requires a code sent by email. */
    EMAIL = "EMAIL",
    /** Requires authentication via an authenticator app. */
    TOTP = "TOTP",
    /** Requires authentication via a push notification. */
    PUSH = "PUSH",
    /** Requires authentication via WebAuthn/passkey. */
    WEBAUTHN = "WEBAUTHN"
}
/** @enumType */
type FactorTypeWithLiterals = FactorType | 'UNKNOWN_FACTOR_TYPE' | 'PASSWORD' | 'SMS' | 'CALL' | 'EMAIL' | 'TOTP' | 'PUSH' | 'WEBAUTHN';
declare enum Status {
    /** Factor requires activation. */
    INACTIVE = "INACTIVE",
    /** Factor is active and can be used for authentication. */
    ACTIVE = "ACTIVE",
    /** Factor is blocked and cannot be used for authentication. The user should reenroll the factor. */
    REQUIRE_REENROLL = "REQUIRE_REENROLL"
}
/** @enumType */
type StatusWithLiterals = Status | 'INACTIVE' | 'ACTIVE' | 'REQUIRE_REENROLL';
interface CustomValue extends CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
/** @oneof */
interface CustomValueValueOneOf {
    /** String value. */
    strValue?: string;
    /** Number value. */
    numValue?: number;
    /** Date value. */
    dateValue?: Date | null;
    /** List value. */
    listValue?: ListValue;
    /** Map value. */
    mapValue?: MapValue;
}
interface ListValue {
    /** Custom value. */
    value?: CustomValue[];
}
interface MapValue {
    /** Mapped custom value. */
    value?: Record<string, CustomValue>;
}
interface RequireMfaData {
    /**
     * The factors available for the user to perform the required MFA.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
interface V1Factor {
    /** Type of verification factor. */
    factorType?: FactorTypeWithLiterals;
    /** Availability status for second factor */
    factorStatus?: FactorStatusWithLiterals;
}
declare enum FactorStatus {
    UNKNOWN_FACTOR_STATUS = "UNKNOWN_FACTOR_STATUS",
    ENABLED = "ENABLED",
    REQUIRE_ACTIVATION = "REQUIRE_ACTIVATION",
    REQUIRE_REENROLL = "REQUIRE_REENROLL",
    ENABLED_BY_RULE = "ENABLED_BY_RULE",
    DISABLED_BY_RULE = "DISABLED_BY_RULE"
}
/** @enumType */
type FactorStatusWithLiterals = FactorStatus | 'UNKNOWN_FACTOR_STATUS' | 'ENABLED' | 'REQUIRE_ACTIVATION' | 'REQUIRE_REENROLL' | 'ENABLED_BY_RULE' | 'DISABLED_BY_RULE';
declare enum MfaReason {
    UNKNOWN_MFA_REASON = "UNKNOWN_MFA_REASON",
    /** Mfa is required due to user settings */
    USER_SETTINGS = "USER_SETTINGS",
    /** Mfa is required due to high risk login */
    HIGH_RISK_LOGIN = "HIGH_RISK_LOGIN"
}
/** @enumType */
type MfaReasonWithLiterals = MfaReason | 'UNKNOWN_MFA_REASON' | 'USER_SETTINGS' | 'HIGH_RISK_LOGIN';
interface MfaChallengeData {
    /** Type of verifation factor. */
    factorType?: FactorTypeWithLiterals;
    verificationChallengeData?: VerificationChallenge;
    /**
     * Factors types the member can choose from to verify themselves.
     * @maxSize 100
     */
    availableFactors?: V1Factor[];
    /** The reason the user is required to perform MFA. */
    reason?: MfaReasonWithLiterals;
}
interface VerificationChallenge extends VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
    /** @maxLength 200 */
    hint?: string | null;
}
/** @oneof */
interface VerificationChallengeFactorChallengeDataOneOf {
    pushData?: PushChallengeData;
    webauthnData?: WebAuthnChallengeData;
}
interface PushChallengeData {
    /**
     * This should be tied to a specific push notification.
     * It will be sent in subsequent requests to verify the factor.
     * @maxLength 36
     */
    transactionId?: string;
}
interface WebAuthnChallengeData {
    /**
     * A unique identifier for this challenge that will be used to correlate
     * the authentication response with this challenge.
     * This should be a cryptographically random GUID to prevent guessing attacks.
     * @format GUID
     */
    challengeId?: string;
    /**
     * The challenge that will be signed by the authenticator during the WebAuthn authentication ceremony.
     * This should be a cryptographically secure random value with at least 16 bytes of entropy.
     * The value is used to prevent replay attacks and MUST be randomly generated by the implementer.
     */
    challenge?: Uint8Array;
    /**
     * The timeout in milliseconds for the WebAuthn authentication ceremony.
     * After this time, the challenge will be considered expired and the authentication will need to be restarted.
     * This is optional and may be overridden by the client if provided.
     * The WebAuthn spec recommends a timeout of at least 1 minute (60000ms).
     */
    timeoutMs?: number | null;
    /**
     * Optional list of credentials that are acceptable for this authentication ceremony.
     * If empty, all credentials associated with the user will be considered.
     * @maxSize 10
     */
    allowCredentials?: PublicKeyCredentialDescriptor[];
    /** Specifies the requirement for user verification during the authentication ceremony. */
    userVerification?: UserVerificationRequirementWithLiterals;
    /**
     * Optional hints to guide the client UI
     * Examples include "security-key" to emphasize external authenticators
     * or "client-device" to emphasize built-in authenticators
     * @maxLength 50
     * @maxSize 10
     */
    hints?: string[];
    /**
     * Optional extensions for the authentication ceremony
     * Provides additional parameters for specialized WebAuthn functionality
     */
    extensions?: AuthenticationExtensionInputs;
}
interface PublicKeyCredentialDescriptor {
    /** The credential ID */
    _id?: Uint8Array;
    /**
     * An optional hint as to the transports used by the credential
     * Examples include "usb", "nfc", "ble", "internal", "hybrid"
     * @maxLength 50
     * @maxSize 10
     */
    transports?: string[];
}
declare enum UserVerificationRequirement {
    /** Default unspecified value */
    USER_VERIFICATION_UNSPECIFIED = "USER_VERIFICATION_UNSPECIFIED",
    /**
     * The Relying Party requires user verification and will fail the operation if the response doesn't have the UV flag
     * set
     */
    USER_VERIFICATION_REQUIRED = "USER_VERIFICATION_REQUIRED",
    /** The Relying Party prefers user verification but will not fail the operation if unavailable */
    USER_VERIFICATION_PREFERRED = "USER_VERIFICATION_PREFERRED",
    /** The Relying Party does not want user verification employed (e.g., to minimize disruption to the user experience) */
    USER_VERIFICATION_DISCOURAGED = "USER_VERIFICATION_DISCOURAGED"
}
/** @enumType */
type UserVerificationRequirementWithLiterals = UserVerificationRequirement | 'USER_VERIFICATION_UNSPECIFIED' | 'USER_VERIFICATION_REQUIRED' | 'USER_VERIFICATION_PREFERRED' | 'USER_VERIFICATION_DISCOURAGED';
interface AuthenticationExtensionInputs extends AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
    /**
     * FIDO AppID Extension (appid)
     * An AppID that was used for previously registered U2F authenticators
     * This makes already-registered U2F credentials forward-compatible with the WebAuthn API
     * @maxLength 256
     */
    appid?: string;
    /**
     * User Verification Method Extension (uvm)
     * Requests the authenticator to report which verification methods were used
     * Examples include fingerprint, PIN, or facial recognition
     */
    uvm?: boolean;
}
/** @oneof */
interface AuthenticationExtensionInputsLargeBlobOperationOneOf {
    /** Read existing large blob data from the authenticator */
    largeBlobRead?: boolean;
    /** Write data to the authenticator's large blob storage */
    largeBlobWrite?: Uint8Array;
}
interface CreateRecoveryTokenRequest {
    /** @format EMAIL */
    email?: string;
}
interface CreateRecoveryTokenResponse {
    /** @maxLength 1000 */
    token?: string;
}
interface SendRecoveryEmailOptions {
    /**
     * 2-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format of the email to be sent.
     *
     * If no language is specified, the language specified in the member's profile is used.
     * @format LANGUAGE
     */
    language?: string | null;
    /** Where to redirect to after successfully resetting the password. */
    redirect?: Redirect;
}
interface SendActivationEmailOptions {
    /** Options for the activation email */
    emailOptions?: EmailOptions;
}
interface RecoverOptions {
    /** new password to set for the identity */
    password?: string | null;
}

export { type VerificationChallengeFactorChallengeDataOneOf as $, AddressTag as A, type Phone as B, type Connection as C, type AddressWrapper as D, EmailTag as E, FactorType as F, type Address as G, type Metadata as H, type Identity as I, type Email as J, type StatusV2 as K, type Factor as L, MfaReason as M, type CustomValue as N, type CustomValueValueOneOf as O, PrivacyStatus as P, type ListValue as Q, type RecoverOptions as R, type SendRecoveryEmailOptions as S, TenantType as T, UserVerificationRequirement as U, type V1CustomValue as V, type MapValue as W, type RequireMfaData as X, type V1Factor as Y, type MfaChallengeData as Z, type VerificationChallenge as _, type SendActivationEmailOptions as a, type PushChallengeData as a0, type WebAuthnChallengeData as a1, type PublicKeyCredentialDescriptor as a2, type AuthenticationExtensionInputs as a3, type AuthenticationExtensionInputsLargeBlobOperationOneOf as a4, type CreateRecoveryTokenRequest as a5, type CreateRecoveryTokenResponse as a6, type StateMachineResponse as b, StateType as c, PhoneTag as d, StatusName as e, Reason as f, Status as g, FactorStatus as h, type RecoveryToken as i, type SendRecoveryEmailRequest as j, type Redirect as k, type SendRecoveryEmailResponse as l, type SendActivationEmailRequest as m, type EmailOptions as n, type SendActivationEmailResponse as o, type RecoverRequest as p, type StateMachineResponseStateDataOneOf as q, type ConnectionTypeOneOf as r, type IdpConnection as s, type AuthenticatorConnection as t, type IdentityProfile as u, type CustomField as v, type V1CustomValueValueOneOf as w, type V1ListValue as x, type V1MapValue as y, type SecondaryEmail as z };
